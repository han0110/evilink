/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-docker-build",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={169:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h});var r=o(594),i=o(42),n=o(966),a=o(688);var s=o(318);async function c({workspace:e,destination:t,report:o}){await s.packUtils.prepareForPack(e,{report:o},async()=>{const r=await s.packUtils.genPackList(e),i=n.Report.progressViaCounter(r.length),c=o.reportProgress(i);try{for(const n of r){const r=a.ppath.join(e.cwd,n),s=a.ppath.join(t,e.relativeCwd,n);o.reportInfo(null,n),await a.xfs.copyPromise(s,r,{overwrite:!0}),i.tick()}}finally{c.stop()}})}function p(e,t){const o=(0,a.toFilename)(t);return a.ppath.isAbsolute(o)?a.ppath.relative(e,o):o}var d=o(827);const f=/^builtin<([^>]+)>$/;var l=function(e,t,o,r){var i,n=arguments.length,a=n<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,o):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,r);else for(var s=e.length-1;s>=0;s--)(i=e[s])&&(a=(n<3?i(a):n>3?i(t,o,a):i(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};class u extends r.BaseCommand{constructor(){super(...arguments),this.args=[]}async execute(){const e=await n.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await n.Project.find(e,this.context.cwd),o=t.getWorkspaceByIdent(n.structUtils.parseIdent(this.workspaceName)),r=function({project:e,workspaces:t,production:o=!1,scopes:r=(o?["dependencies"]:n.Manifest.hardDependencies)}){const i=new Set([...t]);for(const t of i)for(const o of r){const r=t.manifest.getForScope(o).values();for(const t of r){const o=e.tryWorkspaceByDescriptor(t);o&&i.add(o)}}for(const t of e.workspaces)i.has(t)?o&&t.manifest.devDependencies.clear():(t.manifest.dependencies.clear(),t.manifest.devDependencies.clear(),t.manifest.peerDependencies.clear());return i}({project:t,workspaces:[o],production:!0}),i=await async function(e,t="Dockerfile"){const o=(0,a.toFilename)(t);if(a.ppath.isAbsolute(o))return o;const r=[a.ppath.join(e.cwd,o),a.ppath.join(e.project.cwd,o)];for(const e of r)if(await a.xfs.existsPromise(e))return e;throw new Error("Dockerfile is required")}(o,this.dockerFilePath),s=await n.Cache.find(e);return(await n.StreamReport.start({configuration:e,stdout:this.context.stdout,includeLogs:!this.context.quiet},async e=>{await e.startTimerPromise("Resolution Step",async()=>{await t.resolveEverything({report:e,cache:s})}),await e.startTimerPromise("Fetch Step",async()=>{await t.fetchEverything({report:e,cache:s})}),await a.xfs.mktempPromise(async o=>{const l=a.ppath.join(o,(0,a.toFilename)("manifests")),u=a.ppath.join(o,(0,a.toFilename)("packs"));await e.startTimerPromise("Copy files",async()=>{await async function({destination:e,project:t,report:o}){const r=t.configuration.get("rcFilename");o.reportInfo(null,r),await a.xfs.copyPromise(a.ppath.join(e,r),a.ppath.join(t.cwd,r),{overwrite:!0})}({destination:l,project:t,report:e}),await async function({destination:e,project:t,report:o}){const r=a.ppath.join((0,a.toFilename)(".yarn"),(0,a.toFilename)("plugins"));o.reportInfo(null,r),await a.xfs.copyPromise(a.ppath.join(e,r),a.ppath.join(t.cwd,r),{overwrite:!0})}({destination:l,project:t,report:e}),await async function({destination:e,project:t,report:o}){const r=t.configuration.get("yarnPath"),i=a.ppath.relative(t.cwd,r),n=a.ppath.join(e,i);o.reportInfo(null,i),await a.xfs.copyPromise(n,r,{overwrite:!0})}({destination:l,project:t,report:e}),await async function({destination:e,workspaces:t,report:o}){for(const r of t){const t=a.ppath.join(r.relativeCwd,n.Manifest.fileName),i=a.ppath.join(e,t),s={};r.manifest.exportTo(s),o.reportInfo(null,t),await a.xfs.mkdirpPromise(a.ppath.dirname(i)),await a.xfs.writeJsonPromise(i,s)}}({destination:l,workspaces:t.workspaces,report:e}),await async function({destination:e,workspaces:t,report:o}){const r=new Set;for(const i of t)for(const t of i.dependencies.values()){if(!t.range.startsWith("patch:"))continue;const{parentLocator:n,patchPaths:s}=d.patchUtils.parseDescriptor(t);for(const t of s){if(f.test(t))continue;if(a.ppath.isAbsolute(t))continue;if(!n)continue;const s=i.project.getWorkspaceByLocator(n),c=a.ppath.join(s.relativeCwd,t);if(r.has(c))continue;r.add(c);const p=a.ppath.join(s.cwd,t),d=a.ppath.join(e,c);o.reportInfo(null,c),await a.xfs.mkdirpPromise(a.ppath.dirname(d)),await a.xfs.copyFilePromise(p,d)}}}({destination:l,workspaces:t.workspaces,report:e}),await async function({destination:e,project:t,cache:o,report:r}){for(const i of o.markedFiles){const o=a.ppath.relative(t.cwd,i);r.reportInfo(null,o),await a.xfs.copyPromise(a.ppath.join(e,o),i)}}({destination:l,project:t,cache:s,report:e}),await async function({destination:e,project:t,report:o}){const r=(0,a.toFilename)(t.configuration.get("lockfileFilename")),i=a.ppath.join(e,r);o.reportInfo(null,r),await a.xfs.mkdirpPromise(a.ppath.dirname(i)),await a.xfs.writeFilePromise(i,t.generateLockfile())}({destination:l,project:t,report:e}),this.copyFiles&&this.copyFiles.length&&await async function({destination:e,files:t,dockerFilePath:o,report:r}){const i=a.ppath.dirname(o);for(const o of t){const t=p(i,o),n=a.ppath.join(i,t),s=a.ppath.join(e,t);r.reportInfo(null,t),await a.xfs.copyPromise(s,n)}}({destination:l,files:this.copyFiles,dockerFilePath:i,report:e})});for(const t of r){const o=t.manifest.name?n.structUtils.stringifyIdent(t.manifest.name):"";await e.startTimerPromise("Pack workspace "+o,async()=>{await c({workspace:t,report:e,destination:u})})}await n.execUtils.pipevp("docker",["build",...this.args,"-f",i,"."],{cwd:o,strict:!0,stdin:this.context.stdin,stdout:this.context.stdout,stderr:this.context.stderr})})})).exitCode()}}u.usage=i.Command.Usage({category:"Docker-related commands",description:"Build a Docker image for a workspace",details:'\n      This command will build a efficient Docker image which only contains production dependencies for the specified workspace.\n\n      You have to create a Dockerfile in your workspace or your project. You can also specify the path to Dockerfile using the "-f, --file" option.\n\n      Additional arguments can be passed to "docker build" directly, please check the Docker docs for more info: https://docs.docker.com/engine/reference/commandline/build/\n\n      You can copy additional files or folders to a Docker image using the "--copy" option. This is useful for secret keys or configuration files. The files will be copied to "manifests" folder. The path can be either a path relative to the Dockerfile or an absolute path.\n    ',examples:[["Build a Docker image for a workspace","yarn docker build @foo/bar"],["Pass additional arguments to docker build command","yarn docker build @foo/bar -t image-tag"],["Copy additional files to a Docker image","yarn docker build --copy secret.key --copy config.json @foo/bar"]]}),l([i.Command.String()],u.prototype,"workspaceName",void 0),l([i.Command.Proxy()],u.prototype,"args",void 0),l([i.Command.String("-f,--file")],u.prototype,"dockerFilePath",void 0),l([i.Command.Array("--copy")],u.prototype,"copyFiles",void 0),l([i.Command.Path("docker","build")],u.prototype,"execute",null);const h={commands:[u]}},594:e=>{e.exports=require("@yarnpkg/cli")},966:e=>{e.exports=require("@yarnpkg/core")},688:e=>{e.exports=require("@yarnpkg/fslib")},318:e=>{e.exports=require("@yarnpkg/plugin-pack")},827:e=>{e.exports=require("@yarnpkg/plugin-patch")},42:e=>{e.exports=require("clipanion")}},t={};function o(r){if(t[r])return t[r].exports;var i=t[r]={exports:{}};return e[r](i,i.exports,o),i.exports}return o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o(169)})();
return plugin;
}
};